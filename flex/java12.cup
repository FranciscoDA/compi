package compilador;
import java_cup.runtime.*;


/* August 1999 - modified by Gerwin Klein <lsf@jflex.de>
                 to interface with JFlex scanners,
                 allows empty semicolon in class decls.
  
  changed productions:

  class_member_declaration ::=
	  	field_declaration
  	|	method_declaration
    [..]
  	|	interface_declaration
    | SEMICOLON
  	;

  interface_member_declaration ::=
  		constant_declaration
	  |	abstract_method_declaration
  	|	class_declaration
  	|	interface_declaration
    | SEMICOLON
	  ;

*/


/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JDK 1.2 Features added:
  strictfp modifier.
  explicit_constructor_invocation ::= ...
        | primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON ;
  field_access ::= ...
        |       name DOT SUPER DOT IDENTIFIER ;
  method_invocation ::= ...
        |       name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN ;
*/

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal DECVAR;
terminal ENDVAR;
terminal INTEGER;
terminal FLOAT;

terminal LBRACK, RBRACK;
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, COLON;

terminal IF, ELSE, THEN;
terminal WHILE, DO;
terminal END;
terminal PRINT;

terminal LINE_TERMINATOR;

/*terminal TRUNC;
terminal PLUSTRUNC;*/


terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ; // relational_expression
terminal EQEQ, NOTEQ; // equality_expression

terminal ANDAND; // conditional_and_expression
terminal OROR; // conditional_or_expression

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER; // name



non terminal goal;

non terminal type_name;
non terminal literal;

non terminal declaration_block;
non terminal declaration_list;
non terminal type_declaration_outer;
non terminal type_declaration_inner;

non terminal expression;
non terminal term;
non terminal factor;

non terminal statement;
non terminal if_statement;
non terminal while_statement;
non terminal statement_list;

non terminal function_call;
non terminal argument_list;
non terminal bracketed_argument_list;


goal ::=
	declaration_block statement_list
	| statement_list
	;

type_name ::=
	INTEGER
	| FLOAT
	;

literal ::=
	INTEGER_LITERAL
	| FLOATING_POINT_LITERAL
	| STRING_LITERAL
	;

declaration_block ::=
	DECVAR declaration_list ENDVAR LINE_TERMINATOR
	;

declaration_list ::=
	declaration_list type_declaration_outer
	| type_declaration_outer
	;

type_declaration_outer ::=
	LBRACK type_declaration_inner RBRACK LINE_TERMINATOR
	;
	
type_declaration_inner ::=
	IDENTIFIER RBRACK EQ LBRACK type_name
	| IDENTIFIER COMMA type_declaration_inner COMMA type_name
	;

expression ::=
	expression PLUS term
	| expression MINUS term
	| term
	;

term ::=
	term MULT factor
	| term DIV factor
	| factor
	;

factor ::=
	IDENTIFIER
	| literal
	| function_call
	| LPAREN expression RPAREN
	;

statement ::=
	IDENTIFIER COLON EQ expression LINE_TERMINATOR
	| function_call LINE_TERMINATOR
	| PRINT STRING_LITERAL LINE_TERMINATOR
	| PRINT IDENTIFIER LINE_TERMINATOR
	| if_statement
	| while_statement
	;

if_statement ::=
	IF expression THEN LINE_TERMINATOR statement_list END IF LINE_TERMINATOR
	| IF expression THEN statement
	;

while_statement ::=
	WHILE expression DO LINE_TERMINATOR statement_list END WHILE LINE_TERMINATOR
	| WHILE expression DO statement
	;


statement_list ::=
	statement_list statement
	;


function_call ::=
	IDENTIFIER LPAREN argument_list RPAREN
	| IDENTIFIER LPAREN bracketed_argument_list RPAREN
	;

argument_list ::=
	expression
	| argument_list COMMA expression
	;

bracketed_argument_list ::=
	LBRACK argument_list RBRACK
	;