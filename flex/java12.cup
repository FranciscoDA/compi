package compilador;
import java_cup.runtime.*;

/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal DECVAR;
terminal ENDVAR;
terminal INTEGER;
terminal FLOAT;

terminal LBRACK, RBRACK;
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, ASSIGN, LPAREN, RPAREN, COLON;

terminal IF, ELSE, THEN;
terminal WHILE, DO;
terminal END;
terminal PRINT;

terminal TRUNC;
terminal PLUSTRUNC;


terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ; // relational_expression
terminal EQEQ, NOTEQ; // equality_expression
terminal EQ;

terminal ANDAND; // conditional_and_expression
terminal OROR; // conditional_or_expression

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER; // name



non terminal Boolean goal;

non terminal type_name;
non terminal literal;

non terminal declaration_block;
non terminal declaration_list;
non terminal type_declaration_outer;
non terminal type_declaration_inner;

non terminal constructs.Expression expression, term, factor;
non terminal condition;

non terminal constructs.Statement      statement;
non terminal constructs.IfStatement    if_statement;
non terminal constructs.WhileStatement while_statement;
non terminal constructs.Statement      statement_list;

non terminal function_call;
non terminal argument_list;
non terminal bracketed_argument_list;

start with goal;


goal ::=
	declaration_block statement_list {: RESULT = true; :}
	| statement_list                 {: RESULT = false; :}
	;

type_name ::=
	INTEGER
	| FLOAT
	;

literal ::=
	INTEGER_LITERAL
	| FLOATING_POINT_LITERAL
	;

declaration_block ::=
	DECVAR declaration_list ENDVAR
	;

declaration_list ::=
	declaration_list type_declaration_outer
	| type_declaration_outer
	;

type_declaration_outer ::=
	LBRACK type_declaration_inner RBRACK
	;
	
type_declaration_inner ::=
	IDENTIFIER RBRACK EQ LBRACK type_name
	| IDENTIFIER COMMA type_declaration_inner COMMA type_name
	;

expression ::=
	expression PLUS term
	| expression MINUS term
	| MINUS term
	| term
	;

term ::=
	term MULT factor
	| term DIV factor
	| factor
	;

factor ::=
	IDENTIFIER
	| literal
	| function_call
	| LPAREN expression RPAREN
	;

condition ::=
	expression LTEQ expression
	| expression LT expression
	| expression GTEQ expression
	| expression GT expression
	| expression EQEQ expression
	| expression NOTEQ expression
	; 

statement ::=
	IDENTIFIER ASSIGN expression
	| PRINT STRING_LITERAL
	| if_statement
	| while_statement
	;

if_statement ::=
	IF condition THEN statement_list END IF
	| IF condition THEN statement_list ELSE statement_list END IF
	;

while_statement ::=
	WHILE condition DO statement_list END WHILE
	;


statement_list ::=
	statement_list statement
	| statement
	;


function_call ::=
	PLUSTRUNC LPAREN LBRACK argument_list RBRACK RPAREN
	;

argument_list ::=
	argument_list COMMA TRUNC LPAREN expression RPAREN
	| TRUNC LPAREN expression RPAREN
	;
